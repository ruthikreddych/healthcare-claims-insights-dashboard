<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Healthcare Claims Insights Dashboard</title>
    <!-- Bootstrap CSS for basic styling -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" integrity="sha384-H86NJ2N7Pl4gRPVUERp5y1HnUvRb69KqPTfuomG7ITcDKSKes8xeNvCosrL2Z24g" crossorigin="anonymous">
    <!-- Plotly for interactive charts -->
    <script src="https://cdn.plot.ly/plotly-2.30.0.min.js"></script>
    <style>
        body {
            padding: 1.5rem;
            background-color: #f7f8fa;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
        }
        .card-metric {
            border: none;
            border-radius: 0.5rem;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            padding: 1rem;
            margin-bottom: 1rem;
            text-align: center;
            background-color: #ffffff;
        }
        .metric-value {
            font-size: 1.75rem;
            font-weight: 600;
        }
        .metric-label {
            font-size: 0.9rem;
            color: #6c757d;
        }
        .chart-container {
            margin-top: 1.5rem;
        }
        .select-group select {
            min-width: 150px;
        }
    </style>
</head>
<body>
    <div class="container-fluid">
        <h1 class="mb-4">Healthcare Claims Insights Dashboard</h1>

        <!-- Filters -->
        <div class="row g-3 mb-3 select-group">
            <div class="col-sm-4">
                <label for="providerSelect" class="form-label">Provider</label>
                <select id="providerSelect" class="form-select">
                    <option value="All">All Providers</option>
                </select>
            </div>
            <div class="col-sm-4">
                <label for="payerSelect" class="form-label">Payer</label>
                <select id="payerSelect" class="form-select">
                    <option value="All">All Payers</option>
                </select>
            </div>
            <div class="col-sm-4">
                <label for="categorySelect" class="form-label">Service Category</label>
                <select id="categorySelect" class="form-select">
                    <option value="All">All Categories</option>
                </select>
            </div>
        </div>

        <!-- Summary metrics cards -->
        <div id="metricsRow" class="row g-3 mb-4">
            <div class="col-sm-6 col-md-4">
                <div class="card-metric">
                    <div class="metric-value" id="totalClaims">0</div>
                    <div class="metric-label">Total Claims</div>
                </div>
            </div>
            <div class="col-sm-6 col-md-4">
                <div class="card-metric">
                    <div class="metric-value" id="denialRate">0%</div>
                    <div class="metric-label">Denial Rate</div>
                </div>
            </div>
            <div class="col-sm-6 col-md-4">
                <div class="card-metric">
                    <div class="metric-value" id="turnaroundTime">0</div>
                    <div class="metric-label">Avg Turnaround (days)</div>
                </div>
            </div>
            <div class="col-sm-6 col-md-4">
                <div class="card-metric">
                    <div class="metric-value" id="actualReadmissionRate">0%</div>
                    <div class="metric-label">Actual Readmission Rate</div>
                </div>
            </div>
            <div class="col-sm-6 col-md-4">
                <div class="card-metric">
                    <div class="metric-value" id="predReadmissionRate">0%</div>
                    <div class="metric-label">Predicted Readmission Rate</div>
                </div>
            </div>
        </div>

        <!-- Charts -->
        <div class="row chart-container">
            <div class="col-md-6">
                <div id="denialRateChart"></div>
            </div>
            <div class="col-md-6">
                <div id="readmissionRateChart"></div>
            </div>
        </div>

        <!-- Logistic Regression Metrics -->
        <div class="mt-5">
            <h2>Predictive Model Performance</h2>
            <p>The logistic regression model was trained on claim amount and service category features to predict whether a patient will be readmitted. Below are the evaluation metrics on a hold‑out test set.</p>
            <div class="row g-3">
                <div class="col-sm-3">
                    <div class="card-metric">
                        <div class="metric-value" id="metricAccuracy">–</div>
                        <div class="metric-label">Accuracy</div>
                    </div>
                </div>
                <div class="col-sm-3">
                    <div class="card-metric">
                        <div class="metric-value" id="metricPrecision">–</div>
                        <div class="metric-label">Precision</div>
                    </div>
                </div>
                <div class="col-sm-3">
                    <div class="card-metric">
                        <div class="metric-value" id="metricRecall">–</div>
                        <div class="metric-label">Recall</div>
                    </div>
                </div>
                <div class="col-sm-3">
                    <div class="card-metric">
                        <div class="metric-value" id="metricF1">–</div>
                        <div class="metric-label">F1 Score</div>
                    </div>
                </div>
            </div>
            <div class="mt-3">
                <h5>Confusion Matrix</h5>
                <table class="table table-bordered" style="max-width: 400px;">
                    <thead class="table-light">
                        <tr>
                            <th></th>
                            <th>Predicted: No Readmission</th>
                            <th>Predicted: Readmission</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <th>Actual: No Readmission</th>
                            <td id="cmTN">–</td>
                            <td id="cmFP">–</td>
                        </tr>
                        <tr>
                            <th>Actual: Readmission</th>
                            <td id="cmFN">–</td>
                            <td id="cmTP">–</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <script>
        // Global variables to hold loaded data
        let aggData = [];
        let metrics = {};

        // Once the page loads, fetch data and initialise dashboard
        window.addEventListener('DOMContentLoaded', () => {
            Promise.all([
                fetch('claims_aggregated.json').then(res => res.json()),
                fetch('logistic_metrics.json').then(res => res.json())
            ]).then(([aggJson, metricsJson]) => {
                aggData = aggJson;
                metrics = metricsJson;
                populateSelectOptions();
                populateModelMetrics();
                updateDashboard();
            }).catch(err => {
                console.error('Failed to load data:', err);
            });
        });

        // Populate dropdown selections with unique values from aggregated data
        function populateSelectOptions() {
            const providerSelect = document.getElementById('providerSelect');
            const payerSelect = document.getElementById('payerSelect');
            const categorySelect = document.getElementById('categorySelect');
            const providers = Array.from(new Set(aggData.map(row => row.provider_id))).sort();
            const payers = Array.from(new Set(aggData.map(row => row.payer))).sort();
            const categories = Array.from(new Set(aggData.map(row => row.service_category))).sort();
            providers.forEach(p => {
                const opt = document.createElement('option');
                opt.value = p;
                opt.textContent = p;
                providerSelect.appendChild(opt);
            });
            payers.forEach(p => {
                const opt = document.createElement('option');
                opt.value = p;
                opt.textContent = p;
                payerSelect.appendChild(opt);
            });
            categories.forEach(c => {
                const opt = document.createElement('option');
                opt.value = c;
                opt.textContent = c;
                categorySelect.appendChild(opt);
            });
            // Attach change handlers
            providerSelect.addEventListener('change', updateDashboard);
            payerSelect.addEventListener('change', updateDashboard);
            categorySelect.addEventListener('change', updateDashboard);
        }

        // Update model performance metrics
        function populateModelMetrics() {
            document.getElementById('metricAccuracy').textContent = (metrics.accuracy * 100).toFixed(2) + '%';
            document.getElementById('metricPrecision').textContent = (metrics.precision * 100).toFixed(2) + '%';
            document.getElementById('metricRecall').textContent = (metrics.recall * 100).toFixed(2) + '%';
            document.getElementById('metricF1').textContent = (metrics.f1 * 100).toFixed(2) + '%';
            const cm = metrics.confusion_matrix;
            // confusion_matrix = [[TN, FP],[FN, TP]]
            document.getElementById('cmTN').textContent = cm[0][0];
            document.getElementById('cmFP').textContent = cm[0][1];
            document.getElementById('cmFN').textContent = cm[1][0];
            document.getElementById('cmTP').textContent = cm[1][1];
        }

        // Apply filters and update summary metrics and charts
        function updateDashboard() {
            const provider = document.getElementById('providerSelect').value;
            const payer = document.getElementById('payerSelect').value;
            const category = document.getElementById('categorySelect').value;
            const filteredRows = aggData.filter(row => {
                return (provider === 'All' || row.provider_id === provider) &&
                       (payer === 'All' || row.payer === payer) &&
                       (category === 'All' || row.service_category === category);
            });
            const summary = computeSummary(filteredRows);
            // Update summary cards
            document.getElementById('totalClaims').textContent = summary.totalClaims.toLocaleString();
            document.getElementById('denialRate').textContent = (summary.denialRate * 100).toFixed(2) + '%';
            document.getElementById('turnaroundTime').textContent = summary.avgTurnaround.toFixed(1);
            document.getElementById('actualReadmissionRate').textContent = (summary.actualReadmRate * 100).toFixed(2) + '%';
            document.getElementById('predReadmissionRate').textContent = (summary.predReadmRate * 100).toFixed(2) + '%';
            // Build denial rate by payer chart
            buildDenialChart(filteredRows);
            // Build readmission rate by service category chart
            buildReadmissionChart(filteredRows);
        }

        // Compute weighted summary values for a set of aggregated rows
        function computeSummary(rows) {
            let totalClaims = 0;
            let approved = 0;
            let denied = 0;
            let sumTurn = 0;
            let sumActual = 0;
            let sumPred = 0;
            rows.forEach(row => {
                totalClaims += row.total_claims;
                approved += row.approved_claims;
                denied += row.denied_claims;
                sumTurn += row.avg_turnaround_days * row.total_claims;
                sumActual += row.actual_readmission_rate * row.total_claims;
                sumPred += row.predicted_readmission_rate * row.total_claims;
            });
            const denialRate = totalClaims ? denied / totalClaims : 0;
            const avgTurnaround = totalClaims ? sumTurn / totalClaims : 0;
            const actualReadmRate = totalClaims ? sumActual / totalClaims : 0;
            const predReadmRate = totalClaims ? sumPred / totalClaims : 0;
            return {
                totalClaims: totalClaims,
                approved: approved,
                denied: denied,
                denialRate: denialRate,
                avgTurnaround: avgTurnaround,
                actualReadmRate: actualReadmRate,
                predReadmRate: predReadmRate
            };
        }

        // Build denial rate by payer bar chart
        function buildDenialChart(rows) {
            // Group by payer
            const groups = {};
            rows.forEach(row => {
                const k = row.payer;
                if (!groups[k]) {
                    groups[k] = {total: 0, denied: 0};
                }
                groups[k].total += row.total_claims;
                groups[k].denied += row.denied_claims;
            });
            const payers = Object.keys(groups).sort();
            const denialRates = payers.map(p => {
                const g = groups[p];
                return g.total ? g.denied / g.total : 0;
            });
            const trace = {
                x: payers,
                y: denialRates.map(r => r * 100),
                type: 'bar',
                marker: {color: '#007bff'},
            };
            const layout = {
                title: 'Denial Rate by Payer',
                xaxis: { title: 'Payer' },
                yaxis: { title: 'Denial Rate (%)', tickformat: ',.1f' },
                margin: { t: 40, r: 10, l: 50, b: 60 },
                height: 350
            };
            Plotly.newPlot('denialRateChart', [trace], layout, {responsive: true});
        }

        // Build readmission rate by service category bar chart
        function buildReadmissionChart(rows) {
            const groups = {};
            rows.forEach(row => {
                const k = row.service_category;
                if (!groups[k]) {
                    groups[k] = {total: 0, actual: 0, pred: 0};
                }
                groups[k].total += row.total_claims;
                groups[k].actual += row.actual_readmission_rate * row.total_claims;
                groups[k].pred += row.predicted_readmission_rate * row.total_claims;
            });
            const categories = Object.keys(groups).sort();
            const actualRates = categories.map(c => {
                const g = groups[c];
                return g.total ? g.actual / g.total : 0;
            });
            const predRates = categories.map(c => {
                const g = groups[c];
                return g.total ? g.pred / g.total : 0;
            });
            const trace1 = {
                x: categories,
                y: actualRates.map(r => r * 100),
                name: 'Actual',
                type: 'bar',
                marker: {color: '#28a745'}
            };
            const trace2 = {
                x: categories,
                y: predRates.map(r => r * 100),
                name: 'Predicted',
                type: 'bar',
                marker: {color: '#ffc107'}
            };
            const layout = {
                title: 'Readmission Rate by Service Category',
                barmode: 'group',
                xaxis: { title: 'Service Category' },
                yaxis: { title: 'Readmission Rate (%)', tickformat: ',.1f' },
                margin: { t: 40, r: 10, l: 50, b: 60 },
                height: 350
            };
            Plotly.newPlot('readmissionRateChart', [trace1, trace2], layout, {responsive: true});
        }
    </script>
</body>
</html>